### 浏览器渲染过程

* 1.HTML解析出DOM Tree
* 2.CSS解析出Style Rules
* 3.将二者关联生成Render Tree
* 4.布局layout根据Render Tree计算每个节点的信息，就是计算出每个节点的信息；
* 5.Painting 根据计算好的信息绘制整个页面

### Render Tree
* Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程。【Attach：附加，关联】

### 布局Layout

* 创建渲染树后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。
* 对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。

### 绘制Painting
* 在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。

### 重绘Repaint
* 屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。

### 回流Reflow
* 元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。
* Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的。


---------------------

### 脚本处理
* 浏览器解析文档，当遇到`<script>`标签的时候，会立即解析脚本，停止解析文档
* 因为JS可能会改动DOM和CSS，所以继续解析会造成浪费。
* 如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性 defer或者async。(就是一起解析了？)脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和Style Rules上。
* JS为什么放在下面？DOM树，CSSOM树已经完成了，即使有DOM改动，也不会在页面等待时间上有所显示；因为JS的异步的的修改都是单独拿出来进行渲染的；

### CSS优先级
* 优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式；

### 何时执行
```
 (1)window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。
 (2)$(document).ready() 方法可以在DOM载入就绪时,就调用执行绑定的函数。
```




